namespace Atc.Test;

/// <summary>
/// Provides a data source for a data theory, with the data coming from
/// a class implementing IEnumerable&lt;object[]&gt;, combined with auto-generated data
/// specimens generated by AutoFixture and NSubstitute.
/// </summary>
[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
public sealed class ClassAutoNSubstituteDataAttribute : ClassDataAttribute
{
    public ClassAutoNSubstituteDataAttribute(Type @class)
        : base(@class)
    {
        Class = @class;
    }

    /// <summary>
    /// Gets the class type that provides the enumerable data.
    /// </summary>
    public new Type Class { get; }

    /// <summary>
    /// Combines class-provided data rows with AutoFixture generated specimens, honoring any <see cref="FrozenAttribute"/> parameters.
    /// </summary>
    /// <param name="testMethod">The target test method.</param>
    /// <param name="disposalTracker">xUnit disposal tracker (not directly used).</param>
    /// <returns>Augmented data rows with original supplied values followed by generated specimens.</returns>
    /// <remarks>
    /// For each row:
    /// 1. Create a fresh fixture.
    /// 2. Inject supplied values that map to [Frozen] parameters (positional only).
    /// 3. Generate remaining parameters via <see cref="GetSpecimen(IFixture, ParameterInfo)"/>.
    /// 4. Preserve original row metadata.
    /// Unlike member attribute handling, no promotion step is required because class data enumeration typically aligns positions directly.
    /// </remarks>
    public override async ValueTask<IReadOnlyCollection<ITheoryDataRow>> GetData(
        MethodInfo testMethod,
        DisposalTracker disposalTracker)
    {
        var baseRows = await base.GetData(testMethod, disposalTracker).ConfigureAwait(false);
        var parameters = testMethod.GetParameters();
        var frozenValues = parameters
            .Select((p, i) => (Index: i, Parameter: p, p.ParameterType))
            .Where(x => x.Parameter.GetCustomAttribute<FrozenAttribute>() != null)
            .ToArray();
        var injectMethod = typeof(FixtureRegistrar).GetMethod(
            nameof(FixtureRegistrar.Inject),
            BindingFlags.Public | BindingFlags.Static);

        void InjectFrozen(object?[] originalData, IFixture f)
        {
            foreach (var frozenValue in frozenValues)
            {
                if (originalData.Length > frozenValue.Index)
                {
                    injectMethod?
                        .MakeGenericMethod(frozenValue.ParameterType)
                        .Invoke(null, [f, originalData[frozenValue.Index]]);
                }
            }
        }

        var augmented = new List<ITheoryDataRow>(baseRows.Count);
        foreach (var row in baseRows)
        {
            var originalData = row.GetData();
            var fixture = FixtureFactory.Create();

            // Inject frozen values if present in source data (positional only for class data).
            InjectFrozen(originalData, fixture);

            var extendedData = originalData
                .Concat(parameters
                    .Skip(originalData.Length)
                    .Select(p => GetSpecimen(fixture, p)))
                .ToArray();

            // Preserve metadata from original row where possible.
            augmented.Add(new TheoryDataRow(extendedData)
            {
                Explicit = row.Explicit,
                Label = row.Label,
                Skip = row.Skip,
                TestDisplayName = row.TestDisplayName,
                Timeout = row.Timeout,
                Traits = row.Traits ?? new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase),
            });
        }

        return augmented;
    }

    /// <summary>
    /// Resolves a specimen for the given parameter applying parameter-level customizations prior to resolution.
    /// </summary>
    /// <param name="fixture">The per-row fixture instance.</param>
    /// <param name="parameter">The parameter to resolve.</param>
    /// <returns>The resolved specimen instance.</returns>
    /// <remarks>
    /// Customizations are ordered so non-frozen behaviors apply before any potential freezing to ensure
    /// a final form is captured when freezing occurs.
    /// </remarks>
    private static object GetSpecimen(
        IFixture fixture,
        ParameterInfo parameter)
    {
        var attributes = parameter
            .GetCustomAttributes()
            .OfType<IParameterCustomizationSource>()
            .OrderBy(x => x is FrozenAttribute);

        foreach (var attribute in attributes)
        {
            attribute
                .GetCustomization(parameter)
                .Customize(fixture);
        }

        return new SpecimenContext(fixture)
            .Resolve(parameter);
    }
}