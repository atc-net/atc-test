# ATC Test

![NuGet Version](https://img.shields.io/nuget/v/Atc.Test.svg?logo=nuget&style=for-the-badge)

Common tools for writing tests using xUnit, AutoFixture, NSubstitute and FluentAssertions.

## Package References

Add `Atc.Test` to the project containing your tests or to a shared test utilities project.

Typical test project (excerpt):

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <OutputType>Exe</OutputType>
    <UseMicrosoftTestingPlatformRunner>true</UseMicrosoftTestingPlatformRunner>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.14.1" />
    <PackageReference Include="xunit.v3" Version="3.0.1" />
    <PackageReference Include="Atc.Test" Version="$(LatestOrPinned)" />
  </ItemGroup>
</Project>
```

`Atc.Test` depends on `xunit.v3.extensibility.core` for the extensibility APIs, but it intentionally does NOT bring in the `xunit.v3` meta-package for you.

### Why you must still reference xUnit directly

We do not make `xunit.v3` transitive because:

- The `xunit.v3` meta-package pulls in runner-related assets that are not targeted for `netstandard2.1`; this causes NU1701 framework fallback warnings if we referenced it from the multi-targeted library.
- Consumers should control the exact xUnit version (pin or float) in their test project without the library forcing an upgrade cadence.
- Keeping test framework + runner packages at the application (test project) layer avoids unexpected breaking changes when updating `Atc.Test`.
- Separation of concerns: `Atc.Test` provides data attributes/utilities; the test project owns the choice of framework + runner configuration.

If you need a different xUnit patch/minor version, just adjust the `<PackageReference Include="xunit.v3" ... />` in your test project.


## Test Attributes

| Name | Description |
|-|-|
| `AutoNSubstituteData` | Provides auto-generated data specimens generated by AutoFixture and NSubstitute as an extension to XUnit's [Theory] attribute.|
| `InlineAutoNSubstituteData` | Provides a data source for a data theory, with the data coming from inline values combined with auto-generated data specimens generated by AutoFixture and NSubstitute.|
| `MemberAutoNSubstituteData` | Provides a data source for a data theory, with the data coming from one of the following sources and combined with auto-generated data specimens generated by AutoFixture and NSubstitute.|

### Usage Examples

```csharp
public class CalculatorTests
{
    [Theory]
    [AutoNSubstituteData]
    public void AutoData_Generates_Specimens(int a, int b, Calculator sut)
    {
        var result = sut.Add(a, b);
        result.Should().Be(a + b);
    }

    [Theory]
    [InlineAutoNSubstituteData(2, 3)]
    public void InlineAutoData_Mixes_Inline_And_Auto(int a, int b, Calculator sut)
    {
        sut.Add(a, b).Should().Be(5);
    }

    public static IEnumerable<object?[]> MemberSource()
    {
        yield return new object?[] { 1, 2 };
        yield return new object?[] { 10, 20 };
    }

    [Theory]
    [MemberAutoNSubstituteData(nameof(MemberSource))]
    public void MemberAutoData_Augments_Member_Data(int a, int b, Calculator sut)
    {
        sut.Add(a, b).Should().Be(a + b);
    }
}
```

All remaining parameters (after those satisfied by inline/member data) are populated using an AutoFixture `IFixture` customized with NSubstitute for interfaces/abstract classes.

> **Note:**
> NSubstitute is used when the type being created is an interface or abstract class.

### Frozen Reuse Scenarios

When you decorate a parameter with `[Frozen]`, its resolved instance is reused for any other specimens needing that type. The `MemberAutoNSubstituteData` attribute supports an additional convenience: **exact-type promotion** of an earlier supplied value to a later `[Frozen]` parameter whose slot was not part of the supplied member row.

| Scenario | Attribute | Behavior |
|----------|-----------|----------|
| Positional frozen reuse | `ClassAutoNSubstituteData` + `MemberAutoNSubstituteData` | If the data row supplies a value at the same parameter index as a `[Frozen]` parameter, that value is frozen and reused. |
| Exact-type promotion (member data only) | `MemberAutoNSubstituteData` | If a later `[Frozen] T` parameter has no supplied value (index beyond row length), we look for an earlier supplied value whose parameter type is exactly `T` and freeze it. |
| No interface/base promotion | Both | We do NOT promote across interface or base types—only exact parameter type matches. |

#### 1. Positional Reuse

```csharp
[Theory]
[InlineAutoNSubstituteData(42)]
public void Positional_Frozen_Reuses_Inline_Value(
  [Frozen] int number, // inline supplies index 0 -> frozen
  SomeConsumer consumer) // receives the same number if it depends on it
{
  consumer.NumberDependency.Should().Be(number);
}
```

#### 2. Exact-Type Promotion (Member Data Only)

```csharp
public static IEnumerable<object?[]> ServiceRow() => new []
{
  new object?[] { Substitute.For<IMyService>() } // supplies parameter 0 only
};

[Theory]
[MemberAutoNSubstituteData(nameof(ServiceRow))]
public void Promotion_Reuses_Earlier_Same_Type(
  IMyService supplied,              // index 0 supplied
  [Frozen] IMyService frozenLater,  // not supplied -> promoted reuse
  NeedsService consumer)            // receives frozen instance
{
  frozenLater.Should().BeSameAs(supplied);
  consumer.Service.Should().BeSameAs(supplied);
}
```

#### 3. Non-Promotion Across Different Interfaces

```csharp
public interface IFoo {}
public interface IBar {}
public class DualImpl : IFoo, IBar {}

public static IEnumerable<object?[]> DualRow() => new []
{
  new object?[] { new DualImpl() } // supplies IFoo parameter only
};

[Theory]
[MemberAutoNSubstituteData(nameof(DualRow))]
public void Different_Interface_Not_Promoted(
  IFoo foo,                // supplied DualImpl
  [Frozen] IBar bar,       // exact-type mismatch (IBar vs IFoo) -> NOT reused
  UsesBar consumer)
{
  bar.Should().NotBeSameAs(foo);          // separate instance
  consumer.Bar.Should().BeSameAs(bar);    // consumer wired to frozen IBar
}
```

Design Rationale:

- Class data is typically authored with full positional intent—implicit promotion could hide mistakes.
- Member data commonly supplies only a prefix, so exact-type promotion avoids boilerplate duplication while staying predictable.
- Restricting to exact type (no interface/base assignability) prevents accidental cross-interface freezes (e.g., a dual-implemented object hijacking a different abstraction).

## Test Helpers

| Name | Description |
|-|-|
| `EquivalencyAssertionOptionsExtensions` | Extensions for FluentAssertions to compare dates with a precision when using `.BeEquivalentTo()`.|
| `FixtureFactory` | Static factory for creating AutoFixture `Fixture` instances.|
| `ObjectExtensions` | Extensions calling protected members on an object.|
| `SubstituteExtensions` | Extensions for NSubstitutes to wait for calls and get arguments of a received call.|
| `TaskExtensions` | Extensions for Tasks to add timeouts when awaiting. |

## Extensibility

The default `Fixture` returned by the `FixtureFactory.Create()` method is used for all the attributes mentioned above.

To add customizations to this, you can add the `AutoRegisterAttribute` to any custom `ICustomization` or `ISpecimenBuilder` to have it automatically added to the Fixture.

See [`CancellationTokenGenerator`](src/Atc.Test/Customizations/Generators/CancellationTokenGenerator.cs) for an example on how to do this.

## How to contribute

[Contribution Guidelines](https://atc-net.github.io/introduction/about-atc#how-to-contribute)

[Coding Guidelines](https://atc-net.github.io/introduction/about-atc#coding-guidelines)
